/**
 * Feature Import Report PDF Generator
 *
 * Generates a professional PDF report documenting feature import results,
 * including summary statistics, breakdown by entity type, detailed item lists,
 * and any errors.
 */

import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';

// ============================================================================
// Types
// ============================================================================

/** Feature detail for the report */
export interface FeatureDetail {
  action: 'add' | 'update' | 'delete';
  code: string;
  name: string;
  category: string;
  tier?: string;
}

/** Permission detail for the report */
export interface PermissionDetail {
  action: 'add' | 'update' | 'delete';
  featureCode: string;
  permissionCode: string;
  displayName: string;
}

/** Role template detail for the report */
export interface RoleTemplateDetail {
  action: 'add' | 'update' | 'delete';
  featureCode: string;
  permissionCode: string;
  roleKey: string;
  isRecommended: boolean;
}

export interface FeatureImportReportData {
  /** Source filename that was imported */
  sourceFile: string;
  /** Import timestamp */
  importDate: Date;
  /** Overall import status */
  status: 'success' | 'partial' | 'failed';
  /** Summary counts by entity type */
  summary: {
    features: { added: number; updated: number; deleted: number };
    permissions: { added: number; updated: number; deleted: number };
    roleTemplates: { added: number; updated: number; deleted: number };
  };
  /** Array of error messages (if any) */
  errors: string[];
  /** Detailed items (optional, for detailed report) */
  details?: {
    features: FeatureDetail[];
    permissions: PermissionDetail[];
    roleTemplates: RoleTemplateDetail[];
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

function getActionBadgeColor(action: string): [number, number, number] {
  switch (action) {
    case 'add':
      return [34, 197, 94]; // Green
    case 'update':
      return [59, 130, 246]; // Blue
    case 'delete':
      return [239, 68, 68]; // Red
    default:
      return [128, 128, 128]; // Gray
  }
}

function addPageHeader(doc: jsPDF, title: string, pageWidth: number) {
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(66, 66, 66);
  doc.text(title, pageWidth / 2, 15, { align: 'center' });
  doc.setTextColor(0, 0, 0);

  // Divider line
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(0.3);
  doc.line(14, 20, pageWidth - 14, 20);
}

function addFooter(doc: jsPDF, pageHeight: number, pageWidth: number, margin: number) {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);

    // Footer line
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    doc.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);

    // Footer text
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(128, 128, 128);
    doc.text('Generated by StewardTrack', margin, pageHeight - 10);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
  }
}

// ============================================================================
// PDF Generation
// ============================================================================

/**
 * Generate a Feature Import Report PDF and trigger download
 */
export function generateFeatureImportReport(data: FeatureImportReportData): void {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'letter',
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 14;
  let yOffset = 20;

  // ============================================================================
  // Page 1: Summary Page
  // ============================================================================

  // Report Title
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text('Feature Import Report', pageWidth / 2, yOffset, { align: 'center' });
  yOffset += 10;

  // Import Details
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');

  const importDateStr = data.importDate.toLocaleString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });

  doc.text(`Import Date: ${importDateStr}`, pageWidth / 2, yOffset, { align: 'center' });
  yOffset += 5;

  doc.text(`Source File: ${data.sourceFile}`, pageWidth / 2, yOffset, { align: 'center' });
  yOffset += 5;

  // Status Badge
  const statusColors: Record<string, { bg: [number, number, number]; text: [number, number, number] }> = {
    success: { bg: [34, 197, 94], text: [255, 255, 255] },
    partial: { bg: [234, 179, 8], text: [0, 0, 0] },
    failed: { bg: [239, 68, 68], text: [255, 255, 255] },
  };

  const statusLabels: Record<string, string> = {
    success: 'SUCCESS',
    partial: 'PARTIAL SUCCESS',
    failed: 'FAILED',
  };

  const statusConfig = statusColors[data.status] || statusColors.failed;
  const statusLabel = statusLabels[data.status] || 'UNKNOWN';

  // Draw status badge
  const badgeWidth = 40;
  const badgeHeight = 7;
  const badgeX = (pageWidth - badgeWidth) / 2;

  doc.setFillColor(...statusConfig.bg);
  doc.roundedRect(badgeX, yOffset, badgeWidth, badgeHeight, 2, 2, 'F');

  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(...statusConfig.text);
  doc.text(statusLabel, pageWidth / 2, yOffset + 5, { align: 'center' });
  doc.setTextColor(0, 0, 0);

  yOffset += 15;

  // Divider line
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(0.5);
  doc.line(margin, yOffset, pageWidth - margin, yOffset);
  yOffset += 10;

  // Summary Section
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Import Summary', margin, yOffset);
  yOffset += 8;

  // Summary Table
  const summaryHeaders = ['Entity Type', 'Added', 'Updated', 'Deleted', 'Total'];
  const summaryBody = [
    [
      'Features',
      String(data.summary.features.added),
      String(data.summary.features.updated),
      String(data.summary.features.deleted),
      String(data.summary.features.added + data.summary.features.updated + data.summary.features.deleted),
    ],
    [
      'Permissions',
      String(data.summary.permissions.added),
      String(data.summary.permissions.updated),
      String(data.summary.permissions.deleted),
      String(data.summary.permissions.added + data.summary.permissions.updated + data.summary.permissions.deleted),
    ],
    [
      'Role Templates',
      String(data.summary.roleTemplates.added),
      String(data.summary.roleTemplates.updated),
      String(data.summary.roleTemplates.deleted),
      String(data.summary.roleTemplates.added + data.summary.roleTemplates.updated + data.summary.roleTemplates.deleted),
    ],
  ];

  // Calculate totals row
  const totalAdded = data.summary.features.added + data.summary.permissions.added + data.summary.roleTemplates.added;
  const totalUpdated = data.summary.features.updated + data.summary.permissions.updated + data.summary.roleTemplates.updated;
  const totalDeleted = data.summary.features.deleted + data.summary.permissions.deleted + data.summary.roleTemplates.deleted;
  const grandTotal = totalAdded + totalUpdated + totalDeleted;

  summaryBody.push([
    'Total',
    String(totalAdded),
    String(totalUpdated),
    String(totalDeleted),
    String(grandTotal),
  ]);

  autoTable(doc, {
    startY: yOffset,
    head: [summaryHeaders],
    body: summaryBody,
    styles: {
      fontSize: 10,
      cellPadding: 4,
    },
    headStyles: {
      fillColor: [66, 66, 66],
      textColor: [255, 255, 255],
      fontStyle: 'bold',
    },
    bodyStyles: {
      textColor: [0, 0, 0],
    },
    columnStyles: {
      0: { halign: 'left', fontStyle: 'bold' },
      1: { halign: 'center' },
      2: { halign: 'center' },
      3: { halign: 'center' },
      4: { halign: 'center', fontStyle: 'bold' },
    },
    didParseCell: (hookData) => {
      if (hookData.row.index === summaryBody.length - 1 && hookData.section === 'body') {
        hookData.cell.styles.fillColor = [240, 240, 240];
        hookData.cell.styles.fontStyle = 'bold';
      }
    },
    margin: { left: margin, right: margin },
  });

  yOffset = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 10;

  // Errors Section (if any)
  if (data.errors.length > 0) {
    if (yOffset > pageHeight - 60) {
      doc.addPage();
      yOffset = 20;
    }

    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(220, 38, 38);
    doc.text(`Errors (${data.errors.length})`, margin, yOffset);
    doc.setTextColor(0, 0, 0);
    yOffset += 8;

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');

    const maxWidth = pageWidth - margin * 2 - 10;

    data.errors.forEach((error, index) => {
      if (yOffset > pageHeight - 30) {
        doc.addPage();
        yOffset = 20;
      }

      doc.setFont('helvetica', 'bold');
      const bulletText = `${index + 1}.`;
      doc.text(bulletText, margin, yOffset);

      doc.setFont('helvetica', 'normal');
      const errorTextX = margin + 8;
      const splitText = doc.splitTextToSize(error, maxWidth - 8);

      splitText.forEach((line: string, lineIndex: number) => {
        if (yOffset > pageHeight - 20) {
          doc.addPage();
          yOffset = 20;
        }
        doc.text(line, errorTextX, yOffset);
        if (lineIndex < splitText.length - 1) {
          yOffset += 4;
        }
      });

      yOffset += 6;
    });
  }

  // ============================================================================
  // Page 2+: Features Detail
  // ============================================================================

  if (data.details && data.details.features.length > 0) {
    doc.addPage();
    addPageHeader(doc, 'Features Detail', pageWidth);

    const featuresHeaders = ['Action', 'Code', 'Name', 'Category', 'Tier'];
    const featuresBody = data.details.features.map(f => [
      f.action.toUpperCase(),
      f.code,
      f.name,
      f.category,
      f.tier || '-',
    ]);

    autoTable(doc, {
      startY: 25,
      head: [featuresHeaders],
      body: featuresBody,
      styles: {
        fontSize: 8,
        cellPadding: 3,
      },
      headStyles: {
        fillColor: [66, 66, 66],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
      },
      columnStyles: {
        0: { halign: 'center', cellWidth: 18 },
        1: { cellWidth: 45 },
        2: { cellWidth: 50 },
        3: { halign: 'center', cellWidth: 30 },
        4: { halign: 'center', cellWidth: 25 },
      },
      didParseCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 0) {
          const action = hookData.cell.raw as string;
          const color = getActionBadgeColor(action.toLowerCase());
          hookData.cell.styles.textColor = color;
          hookData.cell.styles.fontStyle = 'bold';
        }
      },
      margin: { left: margin, right: margin },
    });
  }

  // ============================================================================
  // Page 3+: Permissions Detail
  // ============================================================================

  if (data.details && data.details.permissions.length > 0) {
    doc.addPage();
    addPageHeader(doc, 'Permissions Detail', pageWidth);

    const permissionsHeaders = ['Action', 'Feature Code', 'Permission Code', 'Display Name'];
    const permissionsBody = data.details.permissions.map(p => [
      p.action.toUpperCase(),
      p.featureCode,
      p.permissionCode,
      p.displayName,
    ]);

    autoTable(doc, {
      startY: 25,
      head: [permissionsHeaders],
      body: permissionsBody,
      styles: {
        fontSize: 8,
        cellPadding: 3,
      },
      headStyles: {
        fillColor: [66, 66, 66],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
      },
      columnStyles: {
        0: { halign: 'center', cellWidth: 18 },
        1: { cellWidth: 45 },
        2: { cellWidth: 45 },
        3: { cellWidth: 60 },
      },
      didParseCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 0) {
          const action = hookData.cell.raw as string;
          const color = getActionBadgeColor(action.toLowerCase());
          hookData.cell.styles.textColor = color;
          hookData.cell.styles.fontStyle = 'bold';
        }
      },
      margin: { left: margin, right: margin },
    });
  }

  // ============================================================================
  // Page 4+: Role Templates Detail (Permission to Role Mapping)
  // ============================================================================

  if (data.details && data.details.roleTemplates.length > 0) {
    doc.addPage();
    addPageHeader(doc, 'Role Permission Assignments', pageWidth);

    const roleTemplatesHeaders = ['Action', 'Permission', 'Role', 'Recommended'];
    const roleTemplatesBody = data.details.roleTemplates.map(rt => [
      rt.action.toUpperCase(),
      rt.permissionCode,
      rt.roleKey,
      rt.isRecommended ? 'Yes' : 'No',
    ]);

    autoTable(doc, {
      startY: 25,
      head: [roleTemplatesHeaders],
      body: roleTemplatesBody,
      styles: {
        fontSize: 8,
        cellPadding: 3,
      },
      headStyles: {
        fillColor: [66, 66, 66],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
      },
      columnStyles: {
        0: { halign: 'center', cellWidth: 18 },
        1: { cellWidth: 55 },
        2: { cellWidth: 35 },
        3: { halign: 'center', cellWidth: 25 },
      },
      didParseCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 0) {
          const action = hookData.cell.raw as string;
          const color = getActionBadgeColor(action.toLowerCase());
          hookData.cell.styles.textColor = color;
          hookData.cell.styles.fontStyle = 'bold';
        }
        // Highlight recommended column
        if (hookData.section === 'body' && hookData.column.index === 3) {
          const value = hookData.cell.raw as string;
          if (value === 'Yes') {
            hookData.cell.styles.textColor = [34, 197, 94]; // Green
            hookData.cell.styles.fontStyle = 'bold';
          }
        }
      },
      margin: { left: margin, right: margin },
    });

    // Add a grouped summary by role
    const lastTableY = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY;

    if (lastTableY < pageHeight - 80) {
      yOffset = lastTableY + 15;
    } else {
      doc.addPage();
      addPageHeader(doc, 'Role Permission Summary', pageWidth);
      yOffset = 25;
    }

    // Group permissions by role
    const rolePermissionMap = new Map<string, string[]>();
    data.details.roleTemplates
      .filter(rt => rt.action !== 'delete' && rt.isRecommended)
      .forEach(rt => {
        const permissions = rolePermissionMap.get(rt.roleKey) || [];
        if (!permissions.includes(rt.permissionCode)) {
          permissions.push(rt.permissionCode);
        }
        rolePermissionMap.set(rt.roleKey, permissions);
      });

    if (rolePermissionMap.size > 0) {
      // Check if we need a section header on the same page
      if (yOffset === 25) {
        // Already added header via addPageHeader
      } else {
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text('Permission Summary by Role', margin, yOffset);
        yOffset += 8;
      }

      const roleSummaryHeaders = ['Role', 'Permissions Assigned'];
      const roleSummaryBody: string[][] = [];

      // Sort roles by typical hierarchy
      const roleOrder = ['tenant_admin', 'senior_pastor', 'associate_pastor', 'ministry_leader', 'treasurer', 'auditor', 'secretary', 'deacon_elder', 'staff', 'volunteer', 'member', 'visitor'];
      const sortedRoles = Array.from(rolePermissionMap.keys()).sort((a, b) => {
        const aIndex = roleOrder.indexOf(a);
        const bIndex = roleOrder.indexOf(b);
        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
      });

      sortedRoles.forEach(role => {
        const permissions = rolePermissionMap.get(role) || [];
        roleSummaryBody.push([
          role,
          permissions.join(', ') || '-',
        ]);
      });

      autoTable(doc, {
        startY: yOffset,
        head: [roleSummaryHeaders],
        body: roleSummaryBody,
        styles: {
          fontSize: 8,
          cellPadding: 3,
        },
        headStyles: {
          fillColor: [59, 130, 246],
          textColor: [255, 255, 255],
          fontStyle: 'bold',
        },
        columnStyles: {
          0: { cellWidth: 35, fontStyle: 'bold' },
          1: { cellWidth: 'auto' },
        },
        margin: { left: margin, right: margin },
      });
    }
  }

  // ============================================================================
  // Footer on all pages
  // ============================================================================

  addFooter(doc, pageHeight, pageWidth, margin);

  // ============================================================================
  // Download
  // ============================================================================

  const timestamp = data.importDate.toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '-');
  const filename = `feature-import-report-${timestamp}.pdf`;
  doc.save(filename);
}
